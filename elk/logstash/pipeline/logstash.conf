input {
  # Logs depuis Filebeat
  beats {
    port => 5044
  }

  # Logs TCP (pour les applications qui envoient directement)
  tcp {
    port => 5000
    codec => json
  }

  # Logs UDP
  udp {
    port => 5000
    codec => json
  }
}

filter {
  # Parser les logs Docker
  if [container][name] {
    mutate {
      add_field => { "container_name" => "%{[container][name]}" }
    }
  }

  # Identifier les services SI Relevés
  if [container_name] =~ /si_releves/ {
    mutate {
      add_field => { "application" => "si-releves" }
    }

    # Parser les logs backend (Node.js)
    if [container_name] =~ /backend/ {
      mutate {
        add_field => { "service" => "backend" }
      }

      # Parser les logs JSON
      if [message] =~ /^\{/ {
        json {
          source => "message"
          target => "app"
        }
      }

      # Extraire les erreurs
      if [message] =~ /ERROR|Error|error/ {
        mutate {
          add_field => { "log_level" => "ERROR" }
          add_tag => ["error"]
        }
      } else if [message] =~ /WARN|Warning|warning/ {
        mutate {
          add_field => { "log_level" => "WARN" }
          add_tag => ["warning"]
        }
      } else if [message] =~ /INFO|Info|info/ {
        mutate {
          add_field => { "log_level" => "INFO" }
        }
      } else {
        mutate {
          add_field => { "log_level" => "DEBUG" }
        }
      }
    }

    # Parser les logs frontend (Nginx)
    if [container_name] =~ /frontend/ {
      mutate {
        add_field => { "service" => "frontend" }
      }

      # Parser les logs Nginx access
      grok {
        match => { "message" => "%{COMBINEDAPACHELOG}" }
        add_tag => ["nginx_access"]
      }
    }

    # Parser les logs MySQL
    if [container_name] =~ /mysql/ {
      mutate {
        add_field => { "service" => "mysql" }
      }

      # Détecter les requêtes lentes
      if [message] =~ /Query_time/ {
        mutate {
          add_tag => ["slow_query"]
        }
      }
    }
  }

  # Ajouter un timestamp si absent
  if ![timestamp] {
    ruby {
      code => "event.set('timestamp', Time.now)"
    }
  }

  # Enrichissement avec des métadonnées
  mutate {
    add_field => {
      "environment" => "staging"
      "index_date" => "%{+YYYY.MM.dd}"
    }
  }
}

output {
  # Envoi vers Elasticsearch avec index par service
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "si-releves-%{[service]:unknown}-%{+YYYY.MM.dd}"

    # Template pour les mappings
    template_name => "si-releves"
    template_overwrite => true
  }

  # Logs généraux
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "logs-%{+YYYY.MM.dd}"
  }

  # Debug: afficher dans stdout (commenter en production)
  # stdout {
  #   codec => rubydebug
  # }
}
